###### **Тема 3. Написание запросов на выборку данных, фильтрацию, сортировку SELECT, WHERE, ORDER BY**
План занятия:
1.  загрузка данных из таблицы формата csv в формате SQL
2. Выборка данных - запрос SELECT
3. Фильтрация данных - конструкция WHERE
4. Упорядочивание данных - конструкция ORDER BY

Конвертация данных в формате csv (формат таблиц Excel) в формат SQL проведем на сайте www.convertcsv.com
файл для тренировки reddit_vm.csv загружен с сайта www.kaggle.com
 После загрузки получим запрос формирования таблицы SQL следующего вида 
 ``` SQL
 CREATE TABLE mytable(
   title     VARCHAR(298) NOT NULL PRIMARY KEY
  ,score     INTEGER  NOT NULL
  ,id        VARCHAR(7) NOT NULL
  ,url       VARCHAR(225)
  ,comms_num INTEGER  NOT NULL
  ,created   NUMERIC(12,1) NOT NULL
  ,body      VARCHAR(8562)
  ,timestamp VARCHAR(19) NOT NULL
);
```
Теперь в Workbanch создадим новую схему к примеру test. находясь в этой схеме (собственно это и есть наша база) . Копированием из сайта convertcsv.com
сформируем команду CREATE TABLE с теми праметрами которые есть в csv файле. Будет создана пустая таблица. Укажем сайту-конвертору что нам нужен только один запрос для всех строк. Это делается утсановкой флага в поле
`Use one INSERT/REPLACE statement with multiple VALUES clauses`
После этого копируем всю полученную информацию в закладке Generate output и формируем копированием запрос в workbanch. Дополнительно укажем что INSERT INTO надо сделать не просто в mytable но в test.mytable. По запросу 
INSERT INTO test.mytableI (title,score,id,url,comms_num,created,body,timestamp) VALUES (Тут будут множество значений csv файла)
Таблица mytable будет заполнена значениями из csv файла
Теперь эта таблица может быть обрабтана различными фукциями
Такими как 
SELECT (выбрать)
Фильтр 
WHERE (где)
ORDER BY (отсортировать по )




###### **Тема 4. Common Table Expressions - написание простых подзапросов. Мотивация использовать CTE**

структура СТЕ 
```SQL
WITH departaments AS (SELECT * FROM company ORDER BY salary)
```
где 
departaments - имя СТЕ;
SELECT * FROM company ORDER BY salary - это тело запроса СТЕ
Использование СТЕ запросоа осуществляется командой
```SQL
SELECT * FROM departaments;
```
Фильтрация вывода а так же сортировка осуществляется либо в теле СТЕ запроса, либо при вызове самого СТЕ запроса
Практическая работа:
_Задача №1 (Условие)_
 1. Сделать выборку с помощью построения CTE по таблице Services. Построить запрос так, чтобы результатом выполнения была выборка, в которой отражены услуги стоимостью от 3000 до 7000.
	
	В созданной базе company значения колонки price не попадают в указанный диапазон. Поэтому сформируем запрос ограничивающий значения от 15000 до 30000 . Для того чтобы осуществить такой запрос можно воспользоваться двумя способами:
	* можно воспользоваться конструкцией and . Тогда условие отбора будет выглядить так 
	```SQL
	WHERE price > 15000 AND price <30000
	  
``` 
	* можно воспользоваться методом between. Тогда условие отбора буедт выглядить следующим образом
	  ```SQL
	WHERE price BETWEEN 15000 AND 30000
```
В общем случае (без отбора) СТЕ запрос выглядит так
``` SQL
	WITH price_CTE as(SELECT id,
	    service_name, price, discount
	FROM services )
	SELECT * FROM price_CTE;
```
Теперь возникает вопрос 
Где именно накладывать отбор? 
Дело в том что отбор можно наложить непосредственно в теле CTE , тогда СТЕ запрос вернет значение уже отобранные по условию фильтра.
Но можно СНАЧАЛА получить ВСЕ значения СТЕ запроса и уже потом наложить фильтр.
В данном - конкретном случае наверное это не имеет принципиального значения - база слишком маленькая. Но в случае когда размеры базы достаточно велики , может возникнуть проблемы со скоростью обработки запроса.
Все же (я думаю) лучше накладывать фильтр непосредственно в теле СТЕ. Тогда итоговый запрос будет выглядить так
```SQL
	WITH price_between as
	(SELECT id,service_name, price, discount
	FROM services
	WHERE price between 15000 and 30000)
	SELECT * FROM price_between;
```
 2. Отсортировать получившиеся данные по возрастанию цен на услуги

Сортировка по возрастанию (от меньшего к большему) осуществляется конструкцией 
```SQL
	ORDER BY price ASC
```
И является сортировкой ПО УМОЛЧАНИЮ поэтому ключевой слово `ASC`  указывать не обязательно. И стало быть запрос
```SQL
	ORDER BY price
```
отработает точно так же.
Если же есть необходимость отсортировать вывод по убыванию (от большего к меньшему), то используют обязательное указание `DESC` . И запрос будет
```SQL
	ORDER BY price DESC
```
Теперь возвращаясь к вопросу "Где сортировать?" ))). Тут все же следует понимать , что данная задача не столько вопрос сортировки-сколько вопрос ПОРЯДКА вывода  (опять это только мое мнение) . А что ? ИМЕЮ ПРАВО ! ))).
Все же я бы затолкал сортировку в тело СТЕ .... но ... в общем вот )))
 ```SQL
	 WITH price_between_sort as
	 (SELECT id, service_name, price, discount
	    FROM services 
	    WHERE price between 15000 and 30000)
	SELECT * FROM price_between_sort ORDER by price ASC;
```
 3. Ограничить выборку услуг до 5 используя ключевое слово limit в вашем SQL запросе
На полученный запрос необходимо наложить ограничение вывода `limit 5`. Теперь СТЕ запрос в итоге должен быть таким 
 ```SQL
	 WITH price_between_sort as
	 (SELECT id, service_name, price, discount
		FROM services 
		WHERE price between 15000 and 30000 
		ORDER by price
		limit 5)
	SELECT * FROM price_between_sort;
	```
Следует так же обратить внимание на то что запрос сформирован в относительных путях . Если использовать пути абсолютные, то запрос будет
```SQL
	WITH price_between as
		(SELECT services.id, services.service_name, services.price, services.discount
		FROM company.services 
		WHERE price between 15000 and 30000
		ORDER by services.price 
		limit 5)
	SELECT * FROM price_between ;
```
и уж коли быть петантичным до не приличия запрос должен быть

```SQL
	WITH price_between_sort as
	(SELECT `services`.`id`,
	    `services`.`service_name`,
	    `services`.`price`,
	    `services`.`discount`
	FROM `company`.`services` 
	WHERE `services`.`price` between 15000 and 30000
	ORDER by `services`.`price` 
	limit 5)
	SELECT * FROM price_between_sort;
```
Вот так вот вроде ))) .... Но я ленив до омерзения Ё ! ))))
Скрин CTE_query.png

_Задача №2 (Условие)_
Обе задачи сводятся:
* к ограничению вывода (нам нужна только одна строка)
* к способу сортировки
  ( если мы хотим получить саму большую цену, тогда соритровка DESC)
  ( если мы хотим получить саму маленькую цену, тогда соритровка ASC)
  Итак:
 1. Сделать выборку с помощью построения CTE по таблице Services. Построить запрос так, чтобы получить самую дешёвую услугу.
```SQL
	WITH price_min as
	(SELECT `services`.`id`,
	    `services`.`service_name`,
	    `services`.`price`, 
	    `services`.`discount`
	FROM `company`.`services` 
	ORDER by `services`.`price` 
	limit 1)
	SELECT * FROM price_min;
```
Скрин price_min.png
2. Теперь на самую дорогую услугу.
   ```SQL
	WITH price_max as
	(SELECT `services`.`id`,
	    `services`.`service_name`,
	    `services`.`price`, 
	    `services`.`discount`
	FROM `company`.`services` 
	ORDER by `services`.`price` DESC 
	limit 1)
	SELECT * FROM price_max;
```
Скрин price_max.png

_Задача №3 (Условие)_
Создать базу movies и загрузить в базу данные из файла movies.sql
При загрузке данных возникла некоторая проблема - загрузчик определил тип данных колонки Popularity и колонки Vote_Average как `NUMERIC`  (псевдоним типа `DECIMAL`). Но часть значений колонок (Popularity точно) выходит за границы доспустимых для данного типа значений. Что привело к некоторму искажению загружаемых данных (данные при загрузке были приведены к допустимому диапазону значений). Чтобы данные загрузились в именно в том виде в котором они находились в файле movies.sql пришлось изменить тип данных колонок Popularity , Vote_Average к типу `FLOAT`.
